% !TeX encoding = ISO-8859-1
\chapter{Software development methodology}
\label{Software development methodology}

Software development methodologies\footnote{\href{https://www.researchgate.net/publication/278300889_Comparison_between_Agile_and_Traditional_software_development_methodologies}{Comparison between Agile and Traditional software development methodologies}} are used to make software development more efficient and predictable. The two main types of software development methodologies are traditional and agile.
 
Traditional methodologies, also known as heavyweight methodologies, are predictive and follow a linear approach. They require defining and documenting all the requirements at the beginning of the process. Some examples of heavyweight methodologies, among many others, are Waterfall, Spiral Model, and Rational Unified Process. Agile methodologies are adaptive and open to change which make them more flexible. Some of the most popular agile methodologies are Scrum, Kanban, and Extreme Programming (XP).

\section{Kanban}
Kanban is an agile methodology, oriented towards visualizing the work, making it flow, reducing waste, and maximizing the product value. The main rules that Kanban follows are visualization, usually via dashboards, limit the work in progress (WIP), which reduces the number of open tasks, and pull value through the system - a task is started only when itâ€™s needed.

 We chose it as a methodology for our project because the product is delivered continuously, and changes are allowed during the whole process, and no estimation of the tasks is needed. That will increase our flexibility and productivity and will decrease the effect of our lack of experience in estimating.


Every few weeks we have meetings with the tutors. During every meeting, the tutors will give us the tasks - code and memory- that we have to finish until the next meeting, including their priority. The date for the next meeting also will be decided during the current one, as the sprint may vary between two and four weeks, depending on the given tasks.

We created a dashboard to visualize the tasks we have. The tasks are two types: coding tasks and memory tasks. Each type has different rules regarding when they have to switch the columns in the board. We decided to have the following columns:
\begin{itemize}
\item To do. Tasks given to us by the tutors created according to the priority given by the tutors to each task (from higher to lower priority). 
\item In progress. Tasks we are currently working on. All tasks in that column will have a particular person assigned. As we are using Kanban, we have limited the WIP (Work In Progress) of the column to 4 assignments to avoid doing more tasks than we can reasonably manage. The completed tasks will be moved to `Testing`.
\item On hold. Activities that we can't continue at the moment. The reason behind this is that they are waiting for another task to finish. When the task could be continued, it is returned to the column `In progress`.
\item Testing. In the case of a coding task, the testing will include code review and automated and/or manual testing. In the case of a memory task, the person who didn't write the particular part will read and correct it. If a problem is spotted, the task will be moved to the column `In progress`. If not, it will go to the column `Ready for review`.
\item Ready for review.  Tasks we have finished but are not yet reviewed by our tutors. The tasks in that column will be reviewed during the next meeting and the tutors will decide which of them will be moved to the column "Done" and which ones are not finished and must be remade.
\item Done. Tasks that are finished, reviewed and approved by the tutors.
\end{itemize}

If the WIP of any of the columns does not allow more tasks, any additional ones will be moved to the column `Hold on`. 
